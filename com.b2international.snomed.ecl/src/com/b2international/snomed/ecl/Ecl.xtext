/*
 * Copyright 2021 B2i Healthcare Pte Ltd, http://b2i.sg
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
grammar com.b2international.snomed.ecl.Ecl hidden(WS, ML_COMMENT, SL_COMMENT)

generate ecl "http://www.b2international.com/snomed/Ecl"
import 'http://www.eclipse.org/emf/2002/Ecore' as ecore

Script:
	{Script} (constraint=ExpressionConstraint)?;

ExpressionConstraint:
	OrExpressionConstraint;

OrExpressionConstraint returns ExpressionConstraint:
	AndExpressionConstraint ({OrExpressionConstraint.left=current} DISJUNCTION right=AndExpressionConstraint)*;

AndExpressionConstraint returns ExpressionConstraint:
	ExclusionExpressionConstraint ({AndExpressionConstraint.left=current} (CONJUNCTION | COMMA) right=ExclusionExpressionConstraint)*;

ExclusionExpressionConstraint returns ExpressionConstraint:
	RefinedExpressionConstraint ({ExclusionExpressionConstraint.left=current} EXCLUSION right=RefinedExpressionConstraint)?;

RefinedExpressionConstraint returns ExpressionConstraint:
	DottedExpressionConstraint ({RefinedExpressionConstraint.constraint=current} COLON refinement=EclRefinement)?;

DottedExpressionConstraint returns ExpressionConstraint:
	SubExpressionConstraint ({DottedExpressionConstraint.constraint=current} DOT attribute=SubExpressionConstraint)*;

SubExpressionConstraint returns ExpressionConstraint:
	ChildOf | ChildOrSelfOf | DescendantOf | DescendantOrSelfOf | ParentOf | ParentOrSelfOf | AncestorOf | AncestorOrSelfOf | EclFocusConcept | FilterConstraint;

EclFocusConcept returns ExpressionConstraint:
	MemberOf | EclConceptReference | Any | NestedExpression;
	
ChildOf:
	LT_EM constraint=EclFocusConcept;

ChildOrSelfOf:
	DBL_LT_EM constraint=EclFocusConcept;

DescendantOf:
	LT constraint=EclFocusConcept;

DescendantOrSelfOf:
	DBL_LT constraint=EclFocusConcept;

ParentOf:
	GT_EM constraint=EclFocusConcept;
	
ParentOrSelfOf:
	DBL_GT_EM constraint=EclFocusConcept;

AncestorOf:
	GT constraint=EclFocusConcept;

AncestorOrSelfOf:
	DBL_GT constraint=EclFocusConcept;

MemberOf:
	CARET constraint=(EclConceptReference | Any | NestedExpression);

EclConceptReference:
	id=SnomedIdentifier (term=TERM_STRING)?;

EclConceptReferenceSet:
	ROUND_OPEN concepts+=EclConceptReference ( concepts+=EclConceptReference)* ROUND_CLOSE; 

Any:
	WILDCARD {Any};

EclRefinement:
	OrRefinement;

OrRefinement returns EclRefinement:
	AndRefinement -> ({OrRefinement.left=current} DISJUNCTION right=AndRefinement)*;

AndRefinement returns EclRefinement:
	SubRefinement -> ({AndRefinement.left=current} (CONJUNCTION | COMMA) right=SubRefinement)*;

SubRefinement returns EclRefinement:
	AttributeConstraint | EclAttributeGroup | NestedRefinement;

NestedRefinement:
	ROUND_OPEN nested=EclRefinement ROUND_CLOSE;

EclAttributeGroup:
	(cardinality=Cardinality)? CURLY_OPEN refinement=EclAttributeSet CURLY_CLOSE;

EclAttributeSet returns EclRefinement:
	OrAttributeSet;

OrAttributeSet returns EclRefinement:
	AndAttributeSet ({OrRefinement.left=current} DISJUNCTION right=AndAttributeSet)*;

AndAttributeSet returns EclRefinement:
	SubAttributeSet ({AndRefinement.left=current} (CONJUNCTION | COMMA) right=SubAttributeSet)*;

SubAttributeSet returns EclRefinement:
	AttributeConstraint | NestedAttributeSet;

NestedAttributeSet returns NestedRefinement:
	ROUND_OPEN nested=EclAttributeSet ROUND_CLOSE;

AttributeConstraint:
	(cardinality=Cardinality)? (reversed?=REVERSED)? attribute=SubExpressionConstraint comparison=Comparison;

Cardinality:
	SQUARE_OPEN min=NonNegativeInteger TO max=MaxValue SQUARE_CLOSE;

Comparison:
	AttributeComparison | DataTypeComparison;

AttributeComparison:
	op=(EQUAL | NOT_EQUAL) value=SubExpressionConstraint;

DataTypeComparison:
	BooleanValueComparison
	| StringValueComparison
	| IntegerValueComparison
	| DecimalValueComparison;

BooleanValueComparison:
	op=(EQUAL | NOT_EQUAL) value=Boolean;

StringValueComparison:
	op=(EQUAL | NOT_EQUAL) value=STRING;

IntegerValueComparison:
	op=(EQUAL | NOT_EQUAL | GT | LT | GTE | LTE) HASH value=Integer;

DecimalValueComparison:
	op=(EQUAL | NOT_EQUAL | GT | LT | GTE | LTE) HASH value=Decimal;

NestedExpression:
	ROUND_OPEN nested=ExpressionConstraint ROUND_CLOSE;

// filters

FilterConstraint:
	DOUBLE_CURLY_OPEN Filter DOUBLE_CURLY_CLOSE;

Filter:
	DisjunctionFilter;

DisjunctionFilter returns Filter:
	ConjunctionFilter ({DisjunctionFilter.left=current} DISJUNCTION right=ConjunctionFilter)*;

ConjunctionFilter returns Filter:
	ExclusionFilter ({ConjunctionFilter.left=current} (CONJUNCTION | COMMA) right=ExclusionFilter)*;

ExclusionFilter returns Filter:
	PropertyFilter ({ExclusionFilter.left=current} EXCLUSION right=PropertyFilter)?;

NestedFilter:
	ROUND_OPEN nested=Filter ROUND_CLOSE;

PropertyFilter:
	TermFilter | LanguageCodeFilter | TypeFilter | DialectFilter | NestedFilter;
 
TermFilter:
	TERM_KEYWORD (TypedTermFilter | TypedTermFilterSet);

TypedTermFilter:
	op=(EQUAL | NOT_EQUAL) (lexicalSearchType=LexicalSearchType COLON)? term=STRING; // no special treatment for the term filter STRING, we allow everything for any lexical search type

TypedTermFilterSet:
	op=(EQUAL | NOT_EQUAL) ROUND_OPEN terms+=TypedTermFilter (terms+=TypedTermFilter)* ROUND_CLOSE;

// TODO not sure if we can support mixed cases here, for now it is not supported
enum LexicalSearchType:
	MATCH="match" | WILD="wild" | REGEX="regex" | EXACT="exact"; // regex and exact match is an extension to ECL 1.5

LanguageCodeFilter:
	LANGUAGE_KEYWORD op=(EQUAL | NOT_EQUAL) (languageCodes+=Alphabetical | ROUND_OPEN languageCodes+=Alphabetical (languageCodes+=Alphabetical)* ROUND_CLOSE);

TypeFilter:
	TypeIdFilter | TypeTokenFilter;

TypeIdFilter:
	TYPEID_KEYWORD op=(EQUAL | NOT_EQUAL) type=(EclConceptReference | EclConceptReferenceSet);

// allowing any STRING to be represented as type token here, validator will restrict it to the available set
TypeTokenFilter:
	TYPE_KEYWORD op=(EQUAL | NOT_EQUAL) (tokens+=Alphabetical | ROUND_OPEN tokens+=Alphabetical (tokens+=Alphabetical)* ROUND_CLOSE);

DialectFilter:
 	DialectIdFilter | DialectAliasFilter;

DialectIdFilter:
	DIALECTID_KEYWORD op=(EQUAL | NOT_EQUAL) (dialects+=Dialect | ROUND_OPEN dialects+=Dialect (dialects+=Dialect)* ROUND_CLOSE);

DialectAliasFilter:
	DIALECT_KEYWORD op=(EQUAL | NOT_EQUAL) (dialects+=DialectAlias | ROUND_OPEN dialects+=DialectAlias (dialects+=DialectAlias)* ROUND_CLOSE);

Dialect:
	languageRefSetId=EclConceptReference (acceptability=Acceptability)?;
	
DialectAlias:
	alias=DialectAliasValue (acceptability=Acceptability)?;

Acceptability:
	AcceptabilityIdSet | AcceptabilityTokenSet;

AcceptabilityIdSet:
	acceptabilities=EclConceptReferenceSet;

AcceptabilityTokenSet:
	ROUND_OPEN acceptabilities+=Alphabetical (acceptabilities+=Alphabetical)* ROUND_CLOSE;
	
// hidden grammar rules
SnomedIdentifier hidden():
	DIGIT_NONZERO (DIGIT_NONZERO | ZERO) (DIGIT_NONZERO | ZERO) (DIGIT_NONZERO | ZERO) (DIGIT_NONZERO | ZERO) (DIGIT_NONZERO | ZERO)+;

NonNegativeInteger returns ecore::EInt hidden():
	ZERO | DIGIT_NONZERO (DIGIT_NONZERO | ZERO)*;

MaxValue returns ecore::EInt hidden():
	NonNegativeInteger | WILDCARD;

Integer returns ecore::EInt hidden():
	(PLUS | DASH)? NonNegativeInteger;

Decimal returns ecore::EBigDecimal hidden():
	(PLUS | DASH)? NonNegativeDecimal;

NonNegativeDecimal returns ecore::EBigDecimal hidden():
	NonNegativeInteger DOT (DIGIT_NONZERO | ZERO)*;
	
Boolean returns ecore::EBoolean hidden(): 
	'true'|'false';

DialectAliasValue returns ecore::EString hidden():
	ALPHA (DASH | ALPHA | ZERO | DIGIT_NONZERO)*;

Alphabetical returns ecore::EString hidden():
	(ALPHA)+;

terminal TERM_STRING:
	"|" (!("|"))* "|";

terminal REVERSED:
	'R';

terminal TO:
	'..';

terminal COMMA:
	',';
	
terminal CONJUNCTION:
	('a' | 'A') ('n' | 'N') ('d' | 'D');

terminal DISJUNCTION:
	('o' | 'O') ('r' | 'R');

terminal EXCLUSION:
	('m' | 'M') ('i' | 'I') ('n' | 'N') ('u' | 'U') ('s' | 'S');
	
terminal ZERO:
	'0';

terminal DIGIT_NONZERO:
	'1'..'9';

terminal COLON:
	':';

terminal CURLY_OPEN:
	'{';

terminal CURLY_CLOSE:
	'}';

terminal ROUND_OPEN:
	'(';

terminal ROUND_CLOSE:
	')';

terminal SQUARE_OPEN:
	'[';

terminal SQUARE_CLOSE:
	']';

terminal PLUS:
	'+';

terminal DASH:
	'-';

terminal CARET:
	'^';

terminal DOT:
	'.';

terminal WILDCARD:
	'*';

terminal EQUAL:
	'=';

terminal NOT_EQUAL:
	'!=';

terminal LT:
	'<';

terminal GT:
	'>';

terminal DBL_LT:
	'<<';

terminal DBL_GT:
	'>>';

terminal LT_EM:
	'<!';

terminal DBL_LT_EM:
	'<<!';
	
terminal GT_EM:
	'>!';

terminal DBL_GT_EM:
	'>>!';

terminal GTE:
	'>=';

terminal LTE:
	'<=';

terminal HASH:
	'#';

terminal DOUBLE_CURLY_OPEN:
	'{{';

terminal DOUBLE_CURLY_CLOSE:
	'}}';

terminal TERM_KEYWORD:
	('t'|'T') ('e'|'E') ('r'|'R') ('m'|'M');

terminal LANGUAGE_KEYWORD:
	('l'|'L') ('a'|'A') ('n'|'N') ('g'|'G') ('u'|'U') ('a'|'A') ('g'|'G') ('e'|'E');

terminal TYPEID_KEYWORD:
	('t'|'T') ('y'|'Y') ('p'|'P') ('e'|'E') ('i'|'I') ('d'|'D');

terminal TYPE_KEYWORD:
	('t'|'T') ('y'|'Y') ('p'|'P') ('e'|'E');

terminal DIALECTID_KEYWORD:
	('d'|'D') ('i'|'I') ('a'|'A') ('l'|'L') ('e'|'E') ('c'|'C') ('t'|'T') ('i'|'I') ('d'|'D');

terminal DIALECT_KEYWORD:
	('d'|'D') ('i'|'I') ('a'|'A') ('l'|'L') ('e'|'E') ('c'|'C') ('t'|'T');

terminal ALPHA:
	'a'..'z';

// comment terminals
terminal WS:
	(' ' | '\t' | '\n' | '\r');

terminal ML_COMMENT:
	'/*'->'*/';

terminal SL_COMMENT:
	'//' !('\n' | '\r')* ('\r'? '\n')?;

terminal STRING:
	'"' ('\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\' | '"'))* '"' |
	"'" ('\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\' | "'"))* "'"; 
