/*
 * Copyright 2021 B2i Healthcare Pte Ltd, http://b2i.sg
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
grammar com.b2international.snomed.ecl.Ecl hidden(WS, ML_COMMENT, SL_COMMENT)

generate ecl "http://www.b2international.com/snomed/Ecl"
import 'http://www.eclipse.org/emf/2002/Ecore' as ecore

Script:
	{Script} (constraint=ExpressionConstraint)?;

ExpressionConstraint:
	OrExpressionConstraint;

OrExpressionConstraint returns ExpressionConstraint:
	AndExpressionConstraint ({OrExpressionConstraint.left=current} DISJUNCTION right=AndExpressionConstraint)*;

AndExpressionConstraint returns ExpressionConstraint:
	ExclusionExpressionConstraint ({AndExpressionConstraint.left=current} (CONJUNCTION | COMMA) right=ExclusionExpressionConstraint)*;

ExclusionExpressionConstraint returns ExpressionConstraint:
	RefinedExpressionConstraint ({ExclusionExpressionConstraint.left=current} EXCLUSION right=RefinedExpressionConstraint)?;

RefinedExpressionConstraint returns ExpressionConstraint:
	DottedExpressionConstraint ({RefinedExpressionConstraint.constraint=current} COLON refinement=EclRefinement)?;

DottedExpressionConstraint returns ExpressionConstraint:
	SubExpressionConstraint ({DottedExpressionConstraint.constraint=current} DOT attribute=SubExpressionConstraint)*;

SubExpressionConstraint returns ExpressionConstraint:
	ChildOf | ChildOrSelfOf | DescendantOf | DescendantOrSelfOf | ParentOf | ParentOrSelfOf | AncestorOf | AncestorOrSelfOf | EclFocusConcept | FilterConstraint;

EclFocusConcept returns ExpressionConstraint:
	MemberOf | EclConceptReference | Any | NestedExpression;
	
ChildOf:
	LT_EM constraint=EclFocusConcept;

ChildOrSelfOf:
	DBL_LT_EM constraint=EclFocusConcept;

DescendantOf:
	LT constraint=EclFocusConcept;

DescendantOrSelfOf:
	DBL_LT constraint=EclFocusConcept;

ParentOf:
	GT_EM constraint=EclFocusConcept;
	
ParentOrSelfOf:
	DBL_GT_EM constraint=EclFocusConcept;

AncestorOf:
	GT constraint=EclFocusConcept;

AncestorOrSelfOf:
	DBL_GT constraint=EclFocusConcept;

MemberOf:
	CARET constraint=(EclConceptReference | Any | NestedExpression);

EclConceptReference:
	id=SnomedIdentifier (term=TERM_STRING)?;

EclConceptReferenceSet:
	ROUND_OPEN concepts+=EclConceptReference ( concepts+=EclConceptReference)* ROUND_CLOSE; 

Any:
	WILDCARD {Any};

EclRefinement:
	OrRefinement;

OrRefinement returns EclRefinement:
	AndRefinement -> ({OrRefinement.left=current} DISJUNCTION right=AndRefinement)*;

AndRefinement returns EclRefinement:
	SubRefinement -> ({AndRefinement.left=current} (CONJUNCTION | COMMA) right=SubRefinement)*;

SubRefinement returns EclRefinement:
	AttributeConstraint | EclAttributeGroup | NestedRefinement;

NestedRefinement:
	ROUND_OPEN nested=EclRefinement ROUND_CLOSE;

EclAttributeGroup:
	(cardinality=Cardinality)? CURLY_OPEN refinement=EclAttributeSet CURLY_CLOSE;

EclAttributeSet returns EclRefinement:
	OrAttributeSet;

OrAttributeSet returns EclRefinement:
	AndAttributeSet ({OrRefinement.left=current} DISJUNCTION right=AndAttributeSet)*;

AndAttributeSet returns EclRefinement:
	SubAttributeSet ({AndRefinement.left=current} (CONJUNCTION | COMMA) right=SubAttributeSet)*;

SubAttributeSet returns EclRefinement:
	AttributeConstraint | NestedAttributeSet;

NestedAttributeSet returns NestedRefinement:
	ROUND_OPEN nested=EclAttributeSet ROUND_CLOSE;

AttributeConstraint:
	(cardinality=Cardinality)? (reversed?=REVERSED)? attribute=SubExpressionConstraint comparison=Comparison;

Cardinality:
	SQUARE_OPEN min=NonNegativeInteger TO max=MaxValue SQUARE_CLOSE;

Comparison:
	AttributeComparison | DataTypeComparison;

AttributeComparison:
	op=NON_NUMERIC_OPERATOR value=SubExpressionConstraint;

DataTypeComparison:
	BooleanValueComparison
	| StringValueComparison
	| IntegerValueComparison
	| DecimalValueComparison;

BooleanValueComparison:
	op=NON_NUMERIC_OPERATOR value=Boolean;

StringValueComparison:
	op=NON_NUMERIC_OPERATOR value=STRING;

IntegerValueComparison:
	op=NUMERIC_OPERATOR HASH value=Integer;

DecimalValueComparison:
	op=NUMERIC_OPERATOR HASH value=Decimal;

NestedExpression:
	ROUND_OPEN nested=ExpressionConstraint ROUND_CLOSE;

// filters

FilterConstraint:
	DOUBLE_CURLY_OPEN Filter DOUBLE_CURLY_CLOSE;

Filter:
	DisjunctionFilter;

DisjunctionFilter returns Filter:
	ConjunctionFilter ({DisjunctionFilter.left=current} DISJUNCTION right=ConjunctionFilter)*;

ConjunctionFilter returns Filter:
	ExclusionFilter ({ConjunctionFilter.left=current} (CONJUNCTION | COMMA) right=ExclusionFilter)*;

ExclusionFilter returns Filter:
	PropertyFilter ({ExclusionFilter.left=current} EXCLUSION right=PropertyFilter)?;

NestedFilter:
	ROUND_OPEN nested=Filter ROUND_CLOSE;

PropertyFilter:
	// ECL 1.5 filters
	TermFilter | 
	LanguageCodeFilter |
	TypeFilter | 
	DialectFilter | 
	// QL 0.1 filters (ECL extensions)	 
	ActiveFilter | 
	PreferredInFilter | 
	AcceptableInFilter | 
	LanguageRefSetFilter | 
	ModuleFilter | 
	CaseSignificanceFilter | 
	// Allows grouping filters for boolean operators
	NestedFilter;
 
TermFilter:
	TERM_KEYWORD (TypedTermFilter | TypedTermFilterSet);

// no special treatment for the term filter STRING, we allow everything for any lexical search type
TypedTermFilter:
	op=NON_NUMERIC_OPERATOR (lexicalSearchType=LEXICAL_SEARCH_TYPE COLON)? term=STRING;

TypedTermFilterSet:
	op=NON_NUMERIC_OPERATOR ROUND_OPEN terms+=TypedTermFilter (terms+=TypedTermFilter)* ROUND_CLOSE;

LanguageCodeFilter:
	LANGUAGE_KEYWORD op=NON_NUMERIC_OPERATOR (languageCodes+=Alphabetical | ROUND_OPEN languageCodes+=Alphabetical (languageCodes+=Alphabetical)* ROUND_CLOSE);

TypeFilter:
	TypeIdFilter | TypeTokenFilter;

TypeIdFilter:
	TYPEID_KEYWORD op=NON_NUMERIC_OPERATOR type=(EclConceptReference | EclConceptReferenceSet);

// allowing any STRING to be represented as type token here, validator will restrict it to the available set
TypeTokenFilter:
	TYPE_KEYWORD op=NON_NUMERIC_OPERATOR (tokens+=Alphabetical | ROUND_OPEN tokens+=Alphabetical (tokens+=Alphabetical)* ROUND_CLOSE);

DialectFilter:
 	DialectIdFilter | DialectAliasFilter;

DialectIdFilter:
	DIALECTID_KEYWORD op=NON_NUMERIC_OPERATOR (dialects+=Dialect | ROUND_OPEN dialects+=Dialect (dialects+=Dialect)* ROUND_CLOSE);

DialectAliasFilter:
	DIALECT_KEYWORD op=NON_NUMERIC_OPERATOR (dialects+=DialectAlias | ROUND_OPEN dialects+=DialectAlias (dialects+=DialectAlias)* ROUND_CLOSE);

Dialect:
	languageRefSetId=EclConceptReference (acceptability=Acceptability)?;
	
DialectAlias:
	alias=DialectAliasValue (acceptability=Acceptability)?;

Acceptability:
	AcceptabilityIdSet | AcceptabilityTokenSet;

AcceptabilityIdSet:
	acceptabilities=EclConceptReferenceSet;

AcceptabilityTokenSet:
	ROUND_OPEN acceptabilities+=Alphabetical (acceptabilities+=Alphabetical)* ROUND_CLOSE;

ActiveFilter:
	(domain=DOMAIN DOT)? ACTIVE_KEYWORD EQUAL (active=Boolean);

ModuleFilter:
	(domain=DOMAIN DOT)? MODULEID_KEYWORD EQUAL moduleId=ExpressionConstraint;

PreferredInFilter:
	PREFERRED_IN_KEYWORD EQUAL languageRefSetId=ExpressionConstraint;

AcceptableInFilter:
	ACCEPTABLE_IN_KEYWORD EQUAL languageRefSetId=ExpressionConstraint;

LanguageRefSetFilter:
	LANGUAGE_REFSET_ID_KEYWORD EQUAL languageRefSetId=ExpressionConstraint;

CaseSignificanceFilter:
	CASE_SIGNIFICANCE_ID_KEYWORD EQUAL caseSignificanceId=ExpressionConstraint;

// hidden grammar rules
SnomedIdentifier hidden():
	DIGIT_NONZERO (DIGIT_NONZERO | ZERO) (DIGIT_NONZERO | ZERO) (DIGIT_NONZERO | ZERO) (DIGIT_NONZERO | ZERO) (DIGIT_NONZERO | ZERO)+;

NonNegativeInteger returns ecore::EInt hidden():
	ZERO | DIGIT_NONZERO (DIGIT_NONZERO | ZERO)*;

MaxValue returns ecore::EInt hidden():
	NonNegativeInteger | WILDCARD;

Integer returns ecore::EInt hidden():
	(PLUS | DASH)? NonNegativeInteger;

Decimal returns ecore::EBigDecimal hidden():
	(PLUS | DASH)? NonNegativeDecimal;

NonNegativeDecimal returns ecore::EBigDecimal hidden():
	NonNegativeInteger DOT (DIGIT_NONZERO | ZERO)*;
	
Boolean returns ecore::EBoolean hidden(): 
	'true'|'false';

DialectAliasValue returns ecore::EString hidden():
	ALPHA (DASH | ALPHA | ZERO | DIGIT_NONZERO)*;

Alphabetical returns ecore::EString hidden():
	(ALPHA)+;

terminal TERM_STRING:
	"|" (!("|"))* "|";

terminal REVERSED:
	'R';

terminal TO:
	'..';

terminal COMMA:
	',';
	
CONJUNCTION:
	'AND';

DISJUNCTION:
	'OR';

EXCLUSION:
	'MINUS';
	
terminal ZERO:
	'0';

terminal DIGIT_NONZERO:
	'1'..'9';

terminal COLON:
	':';

terminal CURLY_OPEN:
	'{';

terminal CURLY_CLOSE:
	'}';

terminal ROUND_OPEN:
	'(';

terminal ROUND_CLOSE:
	')';

terminal SQUARE_OPEN:
	'[';

terminal SQUARE_CLOSE:
	']';

terminal PLUS:
	'+';

terminal DASH:
	'-';

terminal CARET:
	'^';

terminal DOT:
	'.';

terminal WILDCARD:
	'*';

terminal EQUAL:
	'=';

terminal NOT_EQUAL:
	'!=';

terminal LT:
	'<';

terminal GT:
	'>';

terminal DBL_LT:
	'<<';

terminal DBL_GT:
	'>>';

terminal LT_EM:
	'<!';

terminal DBL_LT_EM:
	'<<!';
	
terminal GT_EM:
	'>!';

terminal DBL_GT_EM:
	'>>!';

terminal GTE:
	'>=';

terminal LTE:
	'<=';

terminal HASH:
	'#';

terminal DOUBLE_CURLY_OPEN:
	'{{';

terminal DOUBLE_CURLY_CLOSE:
	'}}';

TERM_KEYWORD:
	'term';

LANGUAGE_KEYWORD:
	'language';

TYPEID_KEYWORD:
	'typeId';

TYPE_KEYWORD:
	'type';

DIALECTID_KEYWORD:
	'dialectId';

DIALECT_KEYWORD:
	'dialect';

ACTIVE_KEYWORD:
	'active';

MODULEID_KEYWORD:
	'moduleId';

PREFERRED_IN_KEYWORD:
	'preferredIn';

ACCEPTABLE_IN_KEYWORD:
	'acceptableIn';

LANGUAGE_REFSET_ID_KEYWORD:
	'languageRefSetId';

CASE_SIGNIFICANCE_ID_KEYWORD:
	'caseSignificanceId';

LEXICAL_SEARCH_TYPE:
	'match' | 'wild' | 'regex' | 'exact'; // regex and exact match is an extension to ECL 1.5

DOMAIN:
	'Concept' | 'Description'; 

NON_NUMERIC_OPERATOR:
	EQUAL | NOT_EQUAL;

NUMERIC_OPERATOR:
	EQUAL | NOT_EQUAL | GT | LT | GTE | LTE;

terminal ALPHA:
	'a'..'z';

// comment terminals
terminal WS:
	(' ' | '\t' | '\n' | '\r');

terminal ML_COMMENT:
	'/*'->'*/';

terminal SL_COMMENT:
	'//' !('\n' | '\r')* ('\r'? '\n')?;

terminal STRING:
	'"' ('\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\' | '"'))* '"' |
	"'" ('\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\' | "'"))* "'"; 
